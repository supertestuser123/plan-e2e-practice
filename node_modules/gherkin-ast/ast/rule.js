"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
const common_1 = require("../common");
const gherkinObject_1 = require("../gherkinObject");
const background_1 = require("./background");
const scenario_1 = require("./scenario");
const scenarioOutline_1 = require("./scenarioOutline");
const tag_1 = require("./tag");
const uniqueObject_1 = require("./uniqueObject");
const debug_1 = require("../debug");
const debug = (0, debug_1.getDebugger)("Rule");
/**
 * Model for Rule
 */
class Rule extends uniqueObject_1.UniqueObject {
    static parse(obj, comments) {
        var _a, _b, _c, _d, _e, _f, _g;
        debug("parse(obj: %o, comments: %d)", obj, (_a = comments === null || comments === void 0 ? void 0 : comments.comments) === null || _a === void 0 ? void 0 : _a.length);
        if (!obj || !obj.rule || !Array.isArray(obj.rule.children)) {
            throw new TypeError("The given object is not a Rule!");
        }
        const { keyword, description, children, name, tags, location } = obj.rule;
        const rule = new Rule(keyword, name, description);
        rule.precedingComment = comments === null || comments === void 0 ? void 0 : comments.parseComment(location, (_b = tags === null || tags === void 0 ? void 0 : tags[tags.length - 1]) === null || _b === void 0 ? void 0 : _b.location);
        rule.tagComment = comments === null || comments === void 0 ? void 0 : comments.parseTagComment(tags);
        rule.tags = tag_1.Tag.parseAll(tags, comments);
        let firstLocation = null;
        rule.elements = children.map((child) => {
            var _a, _b, _c, _d;
            if ((0, gherkinObject_1.isGherkinBackground)(child)) {
                if (!firstLocation) {
                    firstLocation = (_a = child.background) === null || _a === void 0 ? void 0 : _a.location;
                }
                return background_1.Background.parse(child, comments);
            }
            if ((0, gherkinObject_1.isGherkinScenario)(child)) {
                if (!firstLocation) {
                    firstLocation = (_b = child.scenario) === null || _b === void 0 ? void 0 : _b.location;
                }
                if ((_d = (_c = child.scenario) === null || _c === void 0 ? void 0 : _c.examples) === null || _d === void 0 ? void 0 : _d.length) {
                    return scenarioOutline_1.ScenarioOutline.parse(child, comments);
                }
                return scenario_1.Scenario.parse(child, comments);
            }
        });
        rule.descriptionComment = comments === null || comments === void 0 ? void 0 : comments.parseCommentBetween(location, firstLocation);
        debug("parse(this: {keyword: '%s', name: '%s', description: '%s', " +
            "precedingComment: '%s', tagComment: '%s', desctiptionComment: '%s', " +
            "tags: %d, elements: %d})", rule.keyword, rule.name, rule.description, (_c = rule.precedingComment) === null || _c === void 0 ? void 0 : _c.text, (_d = rule.tagComment) === null || _d === void 0 ? void 0 : _d.text, (_e = rule.descriptionComment) === null || _e === void 0 ? void 0 : _e.text, (_f = rule.tags) === null || _f === void 0 ? void 0 : _f.length, (_g = rule.elements) === null || _g === void 0 ? void 0 : _g.length);
        return rule;
    }
    constructor(keyword, name, description) {
        var _a, _b, _c, _d, _e;
        super();
        debug("constructor(keyword: '%s', name: '%s', description: '%s')", keyword, name, description);
        this.keyword = (0, common_1.normalizeString)(keyword);
        this.name = (0, common_1.normalizeString)(name);
        this.description = (0, common_1.normalizeString)(description);
        this.elements = [];
        this.tags = [];
        this.precedingComment = null;
        this.tagComment = null;
        this.descriptionComment = null;
        debug("constructor(this: {keyword: '%s', name: '%s', description: '%s', " +
            "precedingComment: '%s', tagComment: '%s', desctiptionComment: '%s', " +
            "tags: %d, elements: %d})", this.keyword, this.name, this.description, (_a = this.precedingComment) === null || _a === void 0 ? void 0 : _a.text, (_b = this.tagComment) === null || _b === void 0 ? void 0 : _b.text, (_c = this.descriptionComment) === null || _c === void 0 ? void 0 : _c.text, (_d = this.tags) === null || _d === void 0 ? void 0 : _d.length, (_e = this.elements) === null || _e === void 0 ? void 0 : _e.length);
    }
    clone() {
        var _a, _b, _c, _d, _e;
        debug("clone(this: {keyword: '%s', name: '%s', description: '%s', " +
            "precedingComment: '%s', tagComment: '%s', desctiptionComment: '%s', " +
            "tags: %d, elements: %d})", this.keyword, this.name, this.description, (_a = this.precedingComment) === null || _a === void 0 ? void 0 : _a.text, (_b = this.tagComment) === null || _b === void 0 ? void 0 : _b.text, (_c = this.descriptionComment) === null || _c === void 0 ? void 0 : _c.text, (_d = this.tags) === null || _d === void 0 ? void 0 : _d.length, (_e = this.elements) === null || _e === void 0 ? void 0 : _e.length);
        const rule = new Rule(this.keyword, this.name, this.description);
        rule.precedingComment = this.precedingComment ? this.precedingComment.clone() : null;
        rule.tagComment = this.tagComment ? this.tagComment.clone() : null;
        rule.descriptionComment = this.descriptionComment ? this.descriptionComment.clone() : null;
        rule.tags = (0, common_1.cloneArray)(this.tags);
        rule.elements = (0, common_1.cloneArray)(this.elements);
        return rule;
    }
    replace(key, value) {
        debug("replace(key: '%s', value: '%s')", key, value);
        this.name = (0, common_1.replaceAll)(this.name, key, value);
        this.description = (0, common_1.replaceAll)(this.description, key, value);
        (0, common_1.replaceArray)(this.tags, key, value);
        (0, common_1.replaceArray)(this.elements, key, value);
        this.precedingComment && this.precedingComment.replace(key, value);
        this.tagComment && this.tagComment.replace(key, value);
        this.descriptionComment && this.descriptionComment.replace(key, value);
    }
}
exports.Rule = Rule;
//# sourceMappingURL=rule.js.map