"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeDuplicateTags = exports.tag = exports.Tag = void 0;
const tslib_1 = require("tslib");
// @ts-ignore
const ObjectSet = require("object-set-type");
const common_1 = require("../common");
const uniqueObject_1 = require("./uniqueObject");
const debug_1 = require("../debug");
const parseConfig_1 = tslib_1.__importStar(require("../parseConfig"));
const debug = (0, debug_1.getDebugger)("Tag");
const tagFormats = new Map();
tagFormats.set(parseConfig_1.TagFormat.PARAMETERLESS, {
    parse(s) {
        return new Tag(s.match(/^@?(?<name>[^@]+)$/i)[1]);
    },
    toString(tag) {
        return `@${tag.name}`;
    }
});
tagFormats.set(parseConfig_1.TagFormat.FUNCTIONAL, {
    parse(s) {
        const m = s.match(/^@?(?<name>[^(@]+)\((?<value>[^)]+)\)$/i);
        if (m) {
            return new Tag(m[1], m[2]);
        }
        return tagFormats.get(parseConfig_1.TagFormat.PARAMETERLESS).parse(s);
    },
    toString(tag) {
        if (tag.value === undefined) {
            return tagFormats.get(parseConfig_1.TagFormat.PARAMETERLESS).toString(tag);
        }
        return `@${tag.name}(${tag.value})`;
    }
});
tagFormats.set(parseConfig_1.TagFormat.ASSIGNMENT, {
    parse(s) {
        const m = s.match(/^@?(?<name>[^=@]+)=(?<value>.+)$/i);
        if (m) {
            return new Tag(m[1], m[2]);
        }
        return tagFormats.get(parseConfig_1.TagFormat.PARAMETERLESS).parse(s);
    },
    toString(tag) {
        if (tag.value === undefined) {
            return tagFormats.get(parseConfig_1.TagFormat.PARAMETERLESS).toString(tag);
        }
        return `@${tag.name}=${tag.value}`;
    }
});
tagFormats.set(parseConfig_1.TagFormat.UNDERSCORE, {
    parse(s) {
        const m = s.match(/^@?(?<name>[^_@]+)_(?<value>.+)$/i);
        if (m) {
            return new Tag(m[1], m[2]);
        }
        return tagFormats.get(parseConfig_1.TagFormat.PARAMETERLESS).parse(s);
    },
    toString(tag) {
        if (tag.value === undefined) {
            return tagFormats.get(parseConfig_1.TagFormat.PARAMETERLESS).toString(tag);
        }
        return `@${tag.name}_${tag.value}`;
    }
});
/**
 * Model for Tag
 */
class Tag extends uniqueObject_1.UniqueObject {
    static parse(obj, comments) {
        var _a, _b;
        debug("parse(obj: %o, comments: %d)", obj, (_a = comments === null || comments === void 0 ? void 0 : comments.comments) === null || _a === void 0 ? void 0 : _a.length);
        if (!obj || !obj.name) {
            throw new TypeError("The given object is not a Tag!");
        }
        const tag = Tag.parseString(obj.name);
        tag.comment = comments === null || comments === void 0 ? void 0 : comments.parseComment(obj.location);
        debug("parse(this: {name: '%s', value: '%s', comment: '%s')", tag.name, tag.value, (_b = tag.comment) === null || _b === void 0 ? void 0 : _b.text);
        return tag;
    }
    static parseAll(obj, comments) {
        var _a;
        debug("parseAll(obj: %d, comments: %d)", obj === null || obj === void 0 ? void 0 : obj.length, (_a = comments === null || comments === void 0 ? void 0 : comments.comments) === null || _a === void 0 ? void 0 : _a.length);
        if (!Array.isArray(obj) || !obj.length) {
            return [];
        }
        return obj.map(o => this.parse(o, comments));
    }
    static parseString(s) {
        var _a;
        debug("parseString(s: '%s')", s);
        if (!s || typeof s !== "string") {
            throw new TypeError("The given string is not a Gherkin Tag!");
        }
        const { tagFormat } = parseConfig_1.default.get();
        if (!tagFormats.has(tagFormat)) {
            throw new TypeError("The given tag format is not valid!");
        }
        const tag = tagFormats.get(tagFormat).parse(s);
        debug("parseString(this: {name: '%s', value: '%s', comment: '%s')", tag.name, tag.value, (_a = tag.comment) === null || _a === void 0 ? void 0 : _a.text);
        return tag;
    }
    constructor(name, value) {
        var _a;
        super();
        debug("constructor(name: '%s', value: '%s')", name, value);
        this.name = (0, common_1.safeString)(name);
        this.value = value;
        this.comment = null;
        debug("constructor(this: {name: '%s', value: '%s', comment: '%s')", this.name, this.value, (_a = this.comment) === null || _a === void 0 ? void 0 : _a.text);
    }
    clone() {
        var _a;
        debug("clone(this: {name: '%s', value: '%s', comment: '%s')", this.name, this.value, (_a = this.comment) === null || _a === void 0 ? void 0 : _a.text);
        const tag = new Tag(this.name, this.value);
        tag.comment = this.comment ? this.comment.clone() : null;
        return tag;
    }
    replace(key, value) {
        debug("replace(key: '%s', value: '%s')", key, value);
        this.name = (0, common_1.replaceAll)(this.name, key, value);
        this.value = (0, common_1.replaceAll)(this.value, key, value);
        this.comment && this.comment.replace(key, value);
    }
    toString() {
        debug("toString(this: {name: '%s', value: '%s')", this.name, this.value);
        const { tagFormat } = parseConfig_1.default.get();
        if (!tagFormats.has(tagFormat)) {
            throw new TypeError("The given tag format is not valid!");
        }
        return tagFormats.get(tagFormat).toString(this);
    }
}
exports.Tag = Tag;
const tag = (name, value) => {
    debug("static tag(name: '%s', value: '%s')", name, value);
    return new Tag(name, value);
};
exports.tag = tag;
const removeDuplicateTags = (tags) => {
    debug("static removeDuplicateTags(tags: %d)", tags === null || tags === void 0 ? void 0 : tags.length);
    const tagsWithoutID = tags.map(({ name, value }) => ({ name, value }));
    return Array.from(new ObjectSet(tagsWithoutID)).map(({ name, value }) => new Tag(name, value));
};
exports.removeDuplicateTags = removeDuplicateTags;
//# sourceMappingURL=tag.js.map