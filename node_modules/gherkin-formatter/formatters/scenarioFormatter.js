"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = void 0;
const lines_builder_1 = require("lines-builder");
const debug_1 = require("../debug");
const index_1 = require("../index");
const stepFormatter_1 = require("./stepFormatter");
const tagFormatter_1 = require("./tagFormatter");
const debug = (0, debug_1.getDebugger)("scenarioFormatter");
function format(scenario, options) {
    debug("format(scenario: %s, options: %o)", scenario === null || scenario === void 0 ? void 0 : scenario.constructor.name, options);
    if (!scenario) {
        throw new Error("Scenario must be set!");
    }
    const l = (0, lines_builder_1.lines)(`${scenario.keyword}: ${scenario.name}`);
    if (scenario.precedingComment) {
        l.prepend(scenario.precedingComment.text);
    }
    if (scenario.tags.length > 0) {
        l.prepend((0, tagFormatter_1.format)(scenario.tags, options));
    }
    if (scenario.tagComment) {
        l.prepend(scenario.tagComment.text);
    }
    if (scenario.description) {
        l.append((0, lines_builder_1.lines)({ trimLeft: true }, scenario.description));
    }
    if (scenario.descriptionComment) {
        l.append(null, (0, lines_builder_1.lines)(scenario.descriptionComment.text));
    }
    if (scenario.steps.length > 0) {
        if (scenario.description || scenario.descriptionComment) {
            l.append(null);
        }
        const addGroups = (0, index_1.config)(options).separateStepGroups;
        if (addGroups) {
            scenario.useReadableStepKeywords();
        }
        scenario.steps.forEach((step, index) => {
            if (addGroups && step.keyword === "When" && index !== 0) {
                l.append(null);
            }
            l.append((0, lines_builder_1.lines)((0, stepFormatter_1.format)(step)));
        });
    }
    return l.toString();
}
exports.format = format;
//# sourceMappingURL=scenarioFormatter.js.map