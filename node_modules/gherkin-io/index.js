"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = exports.parse = exports.Document = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = require("fs-extra");
const gherkin_streams_1 = require("@cucumber/gherkin-streams");
const gherkin_1 = require("@cucumber/gherkin");
const gherkin_ast_1 = require("gherkin-ast");
const gherkin_formatter_1 = require("gherkin-formatter");
const glob_1 = require("glob");
const path_1 = require("path");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const debug = require("debug")("gherkin-io");
var gherkin_ast_2 = require("gherkin-ast");
Object.defineProperty(exports, "Document", { enumerable: true, get: function () { return gherkin_ast_2.Document; } });
const readFile = (path) => {
    debug("readFile(path: %s)", path);
    return new Promise((fulfill, reject) => {
        const stream = gherkin_streams_1.GherkinStreams.fromPaths([path], {
            includeGherkinDocument: true,
            includePickles: false,
            includeSource: false,
        });
        stream.on("data", fulfill);
        stream.on("error", reject);
    });
};
const parseContent = (content, uri) => {
    debug("parseContent(content.length: %d)", content === null || content === void 0 ? void 0 : content.length);
    return new Promise((fulfill, reject) => {
        const stream = gherkin_streams_1.GherkinStreams.fromSources([(0, gherkin_1.makeSourceEnvelope)(content, uri)], {
            includeGherkinDocument: true,
            includePickles: false,
            includeSource: false,
        });
        stream.on("data", fulfill);
        stream.on("error", reject);
    });
};
const parse = (content, uri, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    debug("parse(content.length: %d, uri: %d)", content === null || content === void 0 ? void 0 : content.length, uri);
    if (!content) {
        throw new Error("Content must be set!");
    }
    if (!uri) {
        throw new Error("URI must be set!");
    }
    gherkin_ast_1.config.set(config);
    const gDocument = yield parseContent(content, uri);
    return gherkin_ast_1.Document.parse(gDocument);
});
exports.parse = parse;
const read = (pattern, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    debug("read(pattern: %s)", pattern);
    if (!pattern) {
        throw new Error("Pattern must be set!");
    }
    // Denormalizing Windows paths
    pattern = pattern.replace(/\\/g, '/');
    const files = (0, glob_1.sync)(pattern, {
        dot: true,
        matchBase: false,
    }).sort();
    debug("read -> files: %o", files);
    if (!files.length) {
        throw new Error(`No matching files for the given pattern: ${pattern}`);
    }
    gherkin_ast_1.config.set(config);
    const documents = [];
    for (const file of files) {
        try {
            const gDocument = yield readFile(file);
            documents.push(gherkin_ast_1.Document.parse(gDocument));
        }
        catch (e) {
            console.warn(`Not valid feature file: ${file}\n`, e);
        }
    }
    return documents;
});
exports.read = read;
const write = (filePath, document, options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    debug("write(filePath: %s, document: %s, options: %o)", filePath, document === null || document === void 0 ? void 0 : document.constructor.name, options);
    if (!filePath) {
        throw new Error("Path must be set!");
    }
    if (!document) {
        throw new Error("Document must be set!");
    }
    filePath = (0, path_1.resolve)(filePath);
    const folder = (0, path_1.dirname)(filePath);
    if (!(0, fs_extra_1.existsSync)(folder)) {
        (0, fs_extra_1.mkdirpSync)(folder);
    }
    yield (0, fs_extra_1.writeFile)((0, path_1.resolve)(filePath), (0, gherkin_formatter_1.format)(document, options), "utf8");
});
exports.write = write;
//# sourceMappingURL=index.js.map