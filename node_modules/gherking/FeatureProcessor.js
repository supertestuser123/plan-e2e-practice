"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureProcessor = void 0;
const tslib_1 = require("tslib");
const gherkin_ast_1 = require("gherkin-ast");
const ElementProcessor_1 = require("./ElementProcessor");
const Processor_1 = require("./Processor");
const RuleProcessor_1 = require("./RuleProcessor");
const TagProcessor_1 = require("./TagProcessor");
const debug_1 = require("./debug");
const debug = (0, debug_1.getDebugger)("FeatureProcessor");
class FeatureProcessor extends Processor_1.Processor {
    constructor(preCompiler) {
        debug("constructor(%o)", preCompiler);
        super(preCompiler);
        this.tagProcessor = new TagProcessor_1.TagProcessor(preCompiler);
        this.ruleProcessor = new RuleProcessor_1.RuleProcessor(preCompiler);
        this.elementProcessor = new ElementProcessor_1.ElementProcessor(preCompiler);
    }
    preFilter(e, p) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore next */
            debug("preFilter(hasPreFeature: %s, e: %s, p: %s)", !!this.preCompiler.preFeature, e === null || e === void 0 ? void 0 : e.constructor.name, p === null || p === void 0 ? void 0 : p.constructor.name);
            return !this.preCompiler.preFeature || (yield this.preCompiler.preFeature(e, p));
        });
    }
    postFilter(e, p) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore next */
            debug("postFilter(hasPostFeature: %s, e: %s, p: %s)", !!this.preCompiler.postFeature, e === null || e === void 0 ? void 0 : e.constructor.name, p === null || p === void 0 ? void 0 : p.constructor.name);
            return !this.preCompiler.postFeature || (yield this.preCompiler.postFeature(e, p));
        });
    }
    process(e, p) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore next */
            debug("process(hasOnFeature: %s, e: %s, p: %s)", !!this.preCompiler.onFeature, e === null || e === void 0 ? void 0 : e.constructor.name, p === null || p === void 0 ? void 0 : p.constructor.name);
            let features = [e];
            if (this.preCompiler.onFeature) {
                const result = yield this.preCompiler.onFeature(e, p);
                if (result === null) {
                    debug("...delete");
                    return [];
                }
                if (Array.isArray(result)) {
                    debug("...Array: %d", result.length);
                    features = result;
                }
                else if (result) {
                    debug("...replace");
                    features = [result];
                }
            }
            for (let i = 0; i < features.length; ++i) {
                const feature = features[i];
                debug("...forEach %d", i);
                feature.tags = yield this.tagProcessor.execute(feature === null || feature === void 0 ? void 0 : feature.tags, feature);
                const elements = feature.elements;
                if (this.hasRule(elements)) {
                    debug("......hasRule %d", i);
                    feature.elements = yield this.ruleProcessor.execute(elements, feature);
                }
                else {
                    debug("......noRule %d", i);
                    feature.elements = yield this.elementProcessor.execute(elements, feature);
                }
            }
            return features;
        });
    }
    hasRule(elements) {
        return !!elements[0] && elements[0] instanceof gherkin_ast_1.Rule;
    }
}
exports.FeatureProcessor = FeatureProcessor;
//# sourceMappingURL=FeatureProcessor.js.map