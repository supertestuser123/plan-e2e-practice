"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleProcessor = void 0;
const tslib_1 = require("tslib");
const ElementProcessor_1 = require("./ElementProcessor");
const Processor_1 = require("./Processor");
const debug_1 = require("./debug");
const debug = (0, debug_1.getDebugger)("RuleProcessor");
class RuleProcessor extends Processor_1.ListProcessor {
    constructor(preCompiler) {
        debug("constructor(%o)", preCompiler);
        super(preCompiler);
        this.elementProcessor = new ElementProcessor_1.ElementProcessor(preCompiler);
    }
    preFilter(e, p, i) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore next */
            debug("preFilter(hasPreRule: %s, e: %s, p: %s, i: %d)", !!this.preCompiler.preRule, e === null || e === void 0 ? void 0 : e.constructor.name, p === null || p === void 0 ? void 0 : p.constructor.name, i);
            return !this.preCompiler.preRule || (yield this.preCompiler.preRule(e, p, i));
        });
    }
    postFilter(e, p, i) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore next */
            debug("postFilter(hasPostRule: %s, e: %s, p: %s, i: %d)", !!this.preCompiler.postRule, e === null || e === void 0 ? void 0 : e.constructor.name, p === null || p === void 0 ? void 0 : p.constructor.name, i);
            return !this.preCompiler.postRule || (yield this.preCompiler.postRule(e, p, i));
        });
    }
    process(e, p, i) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore next */
            debug("process(hasOnRule: %s, e: %s, p: %s, i: %d)", !!this.preCompiler.onRule, e === null || e === void 0 ? void 0 : e.constructor.name, p === null || p === void 0 ? void 0 : p.constructor.name, i);
            let rule = e;
            if (this.preCompiler.onRule) {
                const result = yield this.preCompiler.onRule(e, p, i);
                if (typeof result !== "undefined") {
                    rule = result;
                }
            }
            if (rule) {
                if (Array.isArray(rule)) {
                    debug("...Array: %d", rule.length);
                    rule = yield RuleProcessor.map(rule, this.postProcess.bind(this));
                }
                else {
                    debug("...replace");
                    rule = yield this.postProcess(rule);
                }
            }
            return rule;
        });
    }
    postProcess(e) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            debug("postProcess(elements: %s)", Array.isArray(e.elements));
            e.elements = yield this.elementProcessor.execute(e.elements, e);
            return e;
        });
    }
}
exports.RuleProcessor = RuleProcessor;
//# sourceMappingURL=RuleProcessor.js.map