"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const tslib_1 = require("tslib");
const glob_1 = require("glob");
const fs = require("fs");
const path_1 = require("path");
const debug_1 = require("./debug");
const _1 = require(".");
const gherkin_ast_1 = require("gherkin-ast");
const yargs = require("yargs/yargs");
// @ts-ignore
const lazy = require("lazy-require");
const debug = (0, debug_1.getDebugger)("cli");
const isPackage = (name) => {
    if (/^gpc-[a-z-]+$/.test(name)) {
        return true;
    }
    try {
        require(name);
        return true;
    }
    catch (e) {
        return false;
    }
};
const isDirectory = (path) => {
    try {
        return fs.statSync(path).isDirectory();
    }
    catch (e) {
        return false;
    }
};
const isFile = (path) => {
    try {
        return fs.statSync(path).isFile();
    }
    catch (e) {
        return false;
    }
};
const resolvePath = (path) => path ? (0, path_1.resolve)(path) : null;
const parseConfig = () => {
    debug("parseConfig %o", process.argv);
    return yargs(process.argv)
        .usage("Usage: gherking --config <path> [options]")
        .option("config", {
        type: "string",
        alias: "c",
        coerce: resolvePath,
        default: "./.gherking.json",
        description: "The path of the configuration file which contains the precompilers and their configurations.",
        normalize: true,
        config: true,
        configParser: path => require(path)
    })
        .option("source", {
        type: "string",
        alias: "s",
        description: "The pattern or path of feature files which needs to be precompiled.",
        normalize: true
    })
        .option("base", {
        type: "string",
        alias: "b",
        description: "The base directory of feature files.",
        normalize: true
    })
        .option("destination", {
        type: "string",
        alias: "d",
        description: "The destination directory of precompiled feature files.",
        normalize: true
    })
        .option("install", {
        type: "boolean",
        description: "Whether the missing precompilers (gpc-* packages) should be installed and save to the package.json. "
            + "Packages will be installed in the current folder, and package.json created if it is not there yet.",
        default: false,
    })
        .option("verbose", {
        type: "boolean",
        description: "Whether some information should be displayed on the screen.",
        default: false,
    })
        .option("clean", {
        type: "boolean",
        description: "Whether the destination directory should be clean in advance.",
        default: false,
    })
        .check(argv => prepareConfig(argv))
        .help("help")
        .locale("en")
        .fail((msg, err, ya) => {
        console.error(msg);
        console.error(ya.help());
        if (err)
            throw err;
    })
        .argv;
};
const prepareConfig = (argv) => {
    debug("prepareConfig %o", argv);
    if (!fs.existsSync(argv.config)) {
        throw new Error(`Configuration file does not exist: ${argv.config}!`);
    }
    if (!argv.source && !argv.base) {
        throw new Error("Either source of base option must be set!");
    }
    if (!argv.base) {
        if ((0, glob_1.hasMagic)(argv.source)) {
            throw new Error("Base must be set in case of source is a pattern!");
        }
        if (isDirectory(argv.source)) {
            argv.base = argv.source;
        }
        else {
            argv.base = (0, path_1.dirname)(argv.source);
        }
    }
    else {
        if ((0, glob_1.hasMagic)(argv.base)) {
            throw new Error("Base must be a directory, not a glob pattern!");
        }
        if (!isDirectory(argv.base)) {
            throw new Error("Base must be a directory!");
        }
    }
    if (!argv.source) {
        argv.source = (0, path_1.join)(argv.base, "**", "*.feature");
    }
    else if (!(0, glob_1.hasMagic)(argv.source) && isDirectory(argv.source)) {
        argv.source = (0, path_1.join)(argv.source, "**", "*.feature");
    }
    if (!argv.destination) {
        argv.destination = (0, path_1.join)(argv.base, "dist");
    }
    else if (!isDirectory(argv.destination)) {
        if (fs.existsSync(argv.destination)) {
            throw new Error("Destination must be a directory!");
        }
        fs.mkdirSync(argv.destination);
    }
    if (!Array.isArray(argv.compilers)) {
        throw new Error("Precompilers must be set in the configuration file!");
    }
    else {
        argv.compilers.forEach(config => {
            if (!config.path) {
                throw new Error("Package or path of the precompiler must be set!");
            }
            if (!isPackage(config.path) && !isFile(config.path)) {
                throw new Error(`Path must be either a NPM package name or a JS file: ${config.path}!`);
            }
        });
    }
    if (argv.verbose) {
        console.log("Configuration:", JSON.stringify(argv, null, 2));
    }
    if (!argv.parseConfig) {
        // @ts-ignore
        argv.parseConfig = {};
    }
    else if (typeof argv.parseConfig.tagFormat === "string") {
        const format = argv.parseConfig.tagFormat.toUpperCase();
        if (!(format in gherkin_ast_1.TagFormat)) {
            throw new Error(`Input tag format is not supported: ${format}!`);
        }
        // @ts-ignore
        argv.parseConfig.tagFormat = gherkin_ast_1.TagFormat[format];
    }
    if (!argv.formatOptions) {
        argv.formatOptions = {};
    }
    else if (typeof argv.formatOptions.tagFormat === "string") {
        const format = argv.formatOptions.tagFormat.toUpperCase();
        if (!(format in gherkin_ast_1.TagFormat)) {
            throw new Error(`Output tag format is not supported: ${format}!`);
        }
        // @ts-ignore
        argv.formatOptions.tagFormat = gherkin_ast_1.TagFormat[format];
    }
    if (!argv.formatOptions.tagFormat) {
        argv.formatOptions.tagFormat = argv.parseConfig.tagFormat;
    }
    return argv;
};
const loadCompilers = (compilers, options = {}) => {
    debug("loadCompilers(compilers: %d, options: %o)", compilers.length, options);
    return compilers.map(compiler => {
        let preCompiler;
        if (isPackage(compiler.path)) {
            if (options === null || options === void 0 ? void 0 : options.install) {
                preCompiler = lazy(compiler.path);
            }
            else {
                preCompiler = require(compiler.path);
            }
        }
        else {
            preCompiler = require((0, path_1.resolve)(compiler.path));
        }
        if (typeof preCompiler === "function") {
            return new preCompiler(compiler.configuration || {});
        }
        if (typeof preCompiler !== "object") {
            throw new Error(`Precompiler (${compiler.path}) must be a class or a PreCompiler object: ${preCompiler}!`);
        }
        if (typeof preCompiler.default === "function") {
            return new preCompiler.default(compiler.configuration || {});
        }
        if (typeof preCompiler.default === "object") {
            return preCompiler.default;
        }
        return preCompiler;
    });
};
const getSources = (config) => {
    debug("getSources(source: %s, base: %s, dest: %s)", config.source, config.base, config.destination);
    return (0, glob_1.sync)(config.source.replace(/\\/g, "/"))
        .map(path_1.normalize)
        .map(file => {
        debug("getSources:source: %s", file);
        return ({
            input: file,
            output: (0, path_1.join)(config.destination, file.replace(config.base, "")),
        });
    });
};
const processSource = (source, compilers, parseConfig, formatOptions) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const outputDir = (0, path_1.dirname)(source.output);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    const documents = yield (0, _1.load)(source.input, parseConfig);
    const document = documents[0];
    document.targetFolder = outputDir;
    const outputAst = yield (0, _1.process)(document, ...compilers);
    yield (0, _1.save)(source.output, outputAst, formatOptions);
});
function run() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug("run");
        const config = parseConfig();
        debug("...config: %s", JSON.stringify(config));
        lazy._installSync = lazy.installSync;
        /* istanbul ignore next */
        lazy.installSync = function (...args) {
            debug("...installSync: %o", args);
            config.verbose && console.log(`Installing ${args[0]}`);
            return lazy._installSync(...args);
        };
        const compilers = loadCompilers(config.compilers, config);
        debug("...compilers: %o", compilers);
        const sources = getSources(config);
        debug("...sources: %o", sources);
        if (config.clean && fs.existsSync(config.destination)) {
            debug("...clean: %s", config.destination);
            config.verbose && console.log(`Cleaning ${config.destination}`);
            (fs.rmSync ? fs.rmSync : fs.rmdirSync)(config.destination, { recursive: true });
            fs.mkdirSync(config.destination, { recursive: true });
        }
        for (const source of sources) {
            debug("...processing: %o", source);
            config.verbose && console.log(`Processing ${source.input}`);
            yield processSource(source, compilers, config.parseConfig, config.formatOptions);
            config.verbose && console.log(`Processed file written out ${source.output}`);
        }
    });
}
exports.run = run;
//# sourceMappingURL=cli.js.map