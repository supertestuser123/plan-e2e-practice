"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.save = exports.process = exports.load = void 0;
const tslib_1 = require("tslib");
const gherkin_io_1 = require("gherkin-io");
const DocumentProcessor_1 = require("./DocumentProcessor");
const debug_1 = require("./debug");
const debug = (0, debug_1.getDebugger)("main");
tslib_1.__exportStar(require("./PreCompiler"), exports);
tslib_1.__exportStar(require("gherkin-ast"), exports);
const load = (pattern, config) => {
    debug("load(pattern: %s, config: %o)", pattern, config);
    // @ts-ignore
    return (0, gherkin_io_1.read)(pattern, config);
};
exports.load = load;
const process = (ast, ...preCompilers) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    /* istanbul ignore next */
    debug("process(ast: %s, preCompilers: %d)", ast === null || ast === void 0 ? void 0 : ast.constructor.name, preCompilers.length);
    const documents = [ast];
    for (const preCompiler of preCompilers) {
        debug("...preCompiler: %s", preCompiler === null || preCompiler === void 0 ? void 0 : preCompiler.constructor.name);
        const processor = new DocumentProcessor_1.DocumentProcessor(preCompiler);
        for (let i = 0; i < documents.length; ++i) {
            debug("......document: %d", i);
            const newDocuments = yield processor.execute(documents[i]);
            debug("......new documents: %d", newDocuments.length);
            documents.splice(i, 1, ...newDocuments);
            i += newDocuments.length - 1;
        }
    }
    return documents;
});
exports.process = process;
function save(path, ast, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        /* istanbul ignore next */
        debug("save(path: %s, ast: %s, options: %o)", path, ast === null || ast === void 0 ? void 0 : ast.constructor.name, options);
        if (!path) {
            throw new TypeError("path parameter must be set, either as a string or a PathGenerator");
        }
        if (Array.isArray(ast) && ast.length > 1) {
            debug("...Array: %d", ast.length);
            let pathGenerator = path;
            if (typeof path === "string") {
                if (!/\.feature$/.test(path)) {
                    debug("......adding extension");
                    path += ".feature";
                }
                pathGenerator = (_1, i) => {
                    const newPath = String(path).replace(/\.feature$/, `${i}.feature`);
                    debug("pathGenerator(%d) -> %s", i, newPath);
                    return newPath;
                };
            }
            for (let i = 0; i < ast.length; ++i) {
                let filePath = pathGenerator(ast[i], i);
                if (!/\.feature$/.test(filePath)) {
                    debug("......adding extension");
                    filePath += ".feature";
                }
                debug("...process(path: %s, i: %d)", filePath, i);
                yield (0, gherkin_io_1.write)(filePath, ast[i], options);
            }
        }
        else {
            if (Array.isArray(ast)) {
                ast = ast[0];
            }
            if (typeof path === "function") {
                path = path(ast);
                debug("...path: %s", path);
            }
            if (!/\.feature$/.test(path)) {
                debug("......adding extension");
                path += ".feature";
            }
            yield (0, gherkin_io_1.write)(path, ast, options);
        }
    });
}
exports.save = save;
//# sourceMappingURL=index.js.map